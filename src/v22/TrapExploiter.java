package v22;

import battlecode.common.*;

class TrapInfo {
    TrapType trapType;
    MapLocation trapLocation;
    int timeSinceActivation = 0;
    TrapInfo(TrapType type, MapLocation loc)
    {
        trapType = type;
        trapLocation = loc;
    }

}

public class TrapExploiter
{
    private static TrapInfo[] currentTrapInfos = new TrapInfo[0];
    private static TrapInfo[] activatedTrapInfos = new TrapInfo[0];

    public static boolean canPlaceTrap(RobotController rc, MapLocation loc)
    {
        for (int i = 0; i < currentTrapInfos.length; i++)
        {
            if (currentTrapInfos[i].trapLocation.isAdjacentTo(loc))
            {
                return false;
            }
        }
        return true;
    }
    private static boolean isActivatedTrapStillInEffect(TrapInfo trapInfo)
    {
        int timeUntilDone;
        switch (trapInfo.trapType)
        {
            case EXPLOSIVE:
                timeUntilDone = 3;
                break;
            case STUN:
                timeUntilDone = 5;
                break;
            default:
                timeUntilDone = 0;
        }
        return trapInfo.timeSinceActivation <= timeUntilDone;
    }

    private static int getTrapEffectRadius(TrapInfo trapInfo)
    {
        switch (trapInfo.trapType)
        {
            case EXPLOSIVE:
                return 4;
            case STUN:
                return 13;
            default:
                return 0;
        }
    }

    public static boolean isLocationAffectedByTrap(RobotController rc, MapLocation loc)
    {
        for (int i = 0; i < activatedTrapInfos.length; i++)
        {
            if (loc.isWithinDistanceSquared(activatedTrapInfos[i].trapLocation, getTrapEffectRadius(activatedTrapInfos[i])))
            {
                return true;
            }
        }
        return false;
    }

    public static void updateTrapInfo(RobotController rc) throws GameActionException {
        //First, go through all activated traps and see if we should remove any
        for (int i = 0; i < activatedTrapInfos.length; i++)
        {
            if (isActivatedTrapStillInEffect(activatedTrapInfos[i]))
            {
                activatedTrapInfos[i].timeSinceActivation++;
            }
            else
            {
                //Remove from activatedTrapInfos
                TrapInfo[] newActivated = new TrapInfo[activatedTrapInfos.length - 1];
                for (int j = i; j < activatedTrapInfos.length - 1; j++)
                {
                    activatedTrapInfos[j] = activatedTrapInfos[j + 1];
                }
                System.arraycopy(activatedTrapInfos, 0, newActivated, 0, activatedTrapInfos.length - 1);
                activatedTrapInfos = newActivated;
                i--;
            }
        }

        //Next, go through all currentTrapInfos and see if we should be able to sense them but cannot
        for (int i = 0; i < currentTrapInfos.length; i++)
        {
            MapLocation trapLoc = currentTrapInfos[i].trapLocation;
            if (rc.canSenseLocation(trapLoc))
            {
                if (!rc.senseMapInfo(trapLoc).getTrapType().equals(currentTrapInfos[i].trapType))
                {
                    //The trap got activated! Add to activated
                    TrapInfo[] newActivated = new TrapInfo[activatedTrapInfos.length + 1];
                    System.arraycopy(activatedTrapInfos, 0, newActivated, 0, activatedTrapInfos.length);
                    newActivated[activatedTrapInfos.length] = currentTrapInfos[i];
                    activatedTrapInfos = newActivated;
                }
            }
        }

        //Then, reset currentTrapInfos and sense new traps
        currentTrapInfos = new TrapInfo[0];
        MapInfo[] nearMapInfos = rc.senseNearbyMapInfos();
        for (int i = 0; i < nearMapInfos.length; i++)
        {
            TrapType type = nearMapInfos[i].getTrapType();
            if (!type.equals(TrapType.NONE))
            {
                //Add to currentTrapInfos
                TrapInfo newTrapInfo = new TrapInfo(type, nearMapInfos[i].getMapLocation());
                TrapInfo[] newCurrent = new TrapInfo[currentTrapInfos.length + 1];
                System.arraycopy(currentTrapInfos, 0, newCurrent, 0, currentTrapInfos.length);
                newCurrent[currentTrapInfos.length] = newTrapInfo;
                currentTrapInfos = newCurrent;
            }
        }
    }
}
